@using Microsoft.JSInterop
@inherits WAComponentBase

<wa-drawer @ref="@Element"
           id="@Id"
           @attributes="@AdditionalAttributes"
           style="@StyleNames"
           class="@ClassNames"
           slot="@Slot"
           label="@Title"
           with-header="@withHeader"
           with-footer="@withFooter"
           placement="@PlacementString">
    @if (HeaderActions != null)
    {
        <span slot="header-actions">@HeaderActions</span>
    }
    @ChildContent
    @if (withFooter)
    {
        <span slot="footer">@DrawerFooter</span>
    }
</wa-drawer>

@code {
    private DotNetObjectReference<WADrawer> objRef = default!;

    bool isVisible { get; set; } = false;

    /// <summary>
    /// The drawer's title as displayed in the header. You should always include a relevant title, as it is required for proper accessibility.
    /// </summary>
    [Parameter]
    public string? Title { get; set; }
    bool withHeader
    {
        get
        {
            return (!String.IsNullOrEmpty(Title) || (HeaderActions != null));
        }
    }
    /// <summary>
    /// Renders the drawer with a footer.
    /// </summary>
    [Parameter]
    public RenderFragment? DrawerFooter { get; set; }
    bool withFooter { get { return DrawerFooter != null; } }

    [Parameter]
    public RenderFragment? HeaderActions { get; set; }
    /// <summary>
    /// When enabled, the drawer will be closed when the user clicks outside of it. Defaults to true.
    /// </summary>
    [Parameter]
    public bool LightDismiss { get; set; } = true;

    /// <summary>
    /// The direction from which the drawer will open. Valid options are top, end, bottom, start. Default is end.
    /// </summary>
    [Parameter]
    public Enums.Placement Placement { get; set; } = Enums.Placement.End;
    string PlacementString
    {
        get
        {
            return Placement switch
            {
                Enums.Placement.Top => "top",
                Enums.Placement.Right => "end",
                Enums.Placement.Left => "start",
                Enums.Placement.Bottom => "bottom",
                _ => "end"
            };
        }
    }

    protected override async ValueTask DisposeAsyncCore(bool disposing)
    {
        if (disposing)
        {
            try
            {
                // if (IsRenderComplete)
                // await JSRuntime.InvokeVoidAsync("window.blazorBootstrap.modal.dispose", Id);
            }
            catch (JSDisconnectedException)
            {
                // do nothing
            }

            objRef?.Dispose();

            // if (ModalService is not null && IsServiceModal)
            //     ModalService.OnShow -= OnShowAsync;
        }

        await base.DisposeAsyncCore(disposing);
    }

    protected override async Task OnInitializedAsync()
    {
        objRef ??= DotNetObjectReference.Create(this);

        // if (ModalService is not null && IsServiceModal)
        //     ModalService.OnShow += OnShowAsync;

        await base.OnInitializedAsync();
    }


    /// <summary>
    /// Hides the drawer.
    /// </summary>
    public async Task HideAsync()
    {
        isVisible = false;
        await JSRuntime.InvokeVoidAsync("window.changeModal", Id, false);
    }

    /// <summary>
    /// Shows the drawer.
    /// </summary>
    public async Task ShowAsync()
    {
        isVisible = false;
        await JSRuntime.InvokeVoidAsync("window.changeModal", Id, true);
    }

}
